const CryptoJS = require('crypto-js')
const DeviceDetector = require('device-detector-js')

function isWEB() {
    if (typeof window === 'undefined') {
        return true
    } else {
        return false
    }
}

let Medzy = {
    enc: async function(text, key) {
        try {
            //
            // let crypto;
            // if (isWEB() === true) {
            //     crypto = require('crypto');
            // } else {
            //     crypto = window.crypto
            // }
            // if (crypto !== undefined) {



            // }


            // 
            let k = new TextEncoder().encode(key)
            let t = new TextEncoder().encode(text)

            function BinarytoHex(byteArray) {
                return Array.from(byteArray, byte => ('0' + (byte & 0xFF).toString(16)).slice(-2)).join('');

            }

            function XOR(input) {
                const inputBytes = new TextEncoder().encode(input);

                const encryptedBytes = new Uint8Array(inputBytes.length);

                for (let i = 0; i < inputBytes.length; i++) {
                    encryptedBytes[i] = inputBytes[i] ^ k[i % k.length];
                }

                const encryptedText = new TextDecoder().decode(encryptedBytes);
                return encryptedText;
            }

            function SIMENC(input) {

                let enc = CryptoJS.AES.encrypt(input, key).toString()
                let enc1 = CryptoJS.AES.encrypt(enc, key).toString()

                return enc1
            }

            function manualencrypt(plainbytes, k2) {
                const iv = new Uint8Array(k2.length);
                const chipt = new Uint8Array(plainbytes.length);

                for (let i = 0; i < k2.length; i++) iv[i] = Math.floor(Math.random() * 256);
                for (let i = 0; i < plainbytes.length; i++) chipt[i] = (plainbytes[i] ^ iv[i % iv.length]) ^ k2[i % k2.length];

                const encrypted = new Uint8Array(iv.length + chipt.length);
                encrypted.set(iv);
                encrypted.set(chipt, iv.length);

                return btoa(String.fromCharCode(...encrypted));
            }

            //
            // async function ENCRYPT(deriveKey) {
            //     let iv = crypto.getRandomValues(new Uint8Array(12))
            //     return crypto.subtle.encrypt({
            //         name: 'AES-GCM',
            //         iv: iv
            //     }, deriveKey, t).then(chiptext => {
            //         let encrypted = BinarytoHex(new Uint8Array(chiptext))
            //         let ivs = BinarytoHex(iv)
            //         let combine = `${encrypted}+${ivs}`
            //         return combine
            //     }).catch(er => {
            //         console.error(`Encryption Failed: ${er}`)
            //     })
            // }

            //

            // let keyMaterial = await crypto.subtle.importKey(
            //     'raw',
            //     k, { name: 'PBKDF2' },
            //     false, ['deriveKey']
            // )

            // let deriveKey = await crypto.subtle.deriveKey({
            //     'name': 'PBKDF2',
            //     'salt': new Uint8Array(16),
            //     "iterations": 100000,
            //     "hash": "SHA-256",
            // }, keyMaterial, { name: 'AES-GCM', 'length': 256 }, true, ['encrypt', 'decrypt'])

            // let data = await ENCRYPT(deriveKey);
            // 

            let data2 = XOR(text)
            let dup = SIMENC(data2)
            return manualencrypt(new TextEncoder().encode(dup), k)

        } catch (e) {
            console.error(`Failed to encrypt: -> ${e}`)
            console.group(e)
        }
    },
    dec: async function(text, key) {
        try {

            let k = new TextEncoder().encode(key)
            let t = new TextEncoder().encode(text)

            function manualdecrypt(chitxt, k2) {
                const encrypted = new Uint8Array([...atob(chitxt)].map(c => c.charCodeAt(0)));
                const iv = encrypted.slice(0, k2.length);
                const chipt = encrypted.slice(k2.length);

                for (let i = 0; i < chipt.length; i++) {
                    chipt[i] ^= k2[i % k2.length] ^ iv[i % iv.length];
                }

                return String.fromCharCode(...chipt);
            }

            //

            function SIMDEC(encryptedInput, key) {
                let en = CryptoJS.AES.decrypt(encryptedInput, key).toString(CryptoJS.enc.Utf8)
                let en1 = CryptoJS.AES.decrypt(en, key).toString(CryptoJS.enc.Utf8)
                return en1

            }

            //

            function XORDecrypt(encryptedText, k) {
                const decryptedBytes = new Uint8Array([...encryptedText].map((c, i) => c.charCodeAt(0) ^ k[i % k.length]));
                return new TextDecoder().decode(decryptedBytes);
            }

            //

            // function HexToBinary(hexString) {
            //     let bytes = [];
            //     for (let i = 0; i < hexString.length; i += 2) {
            //         bytes.push(parseInt(hexString.substr(i, 2), 16));
            //     }
            //     return new Uint8Array(bytes);
            // }

            // let keyMaterial = await crypto.subtle.importKey(
            //     'raw',
            //     k, { name: 'PBKDF2' },
            //     false, ['deriveKey']
            // )

            // let deriveKey = await crypto.subtle.deriveKey({
            //     'name': 'PBKDF2',
            //     'salt': new Uint8Array(16),
            //     "iterations": 100000,
            //     "hash": "SHA-256",
            // }, keyMaterial, { name: 'AES-GCM', 'length': 256 }, true, ['encrypt', 'decrypt'])


            // async function decryptText(ciphertext, iv, kp) {
            //     return crypto.subtle.decrypt({
            //                 name: 'AES-GCM',
            //                 iv: iv
            //             },
            //             kp,
            //             ciphertext
            //         )
            //         .then(decryptedData => {
            //             const decoder = new TextDecoder();
            //             return decoder.decode(decryptedData);
            //         })
            //         .catch(error => {
            //             console.error('Decryption Error:', error);
            //         });
            // }

            // // 

            let dec1 = manualdecrypt(text, k)
            let dec2 = SIMDEC(dec1, key)

            let dec3 = XORDecrypt(dec2, k)

            // let encrypted = HexToBinary(dec3.split('+')[0])
            // let iv = HexToBinary(dec3.split('+')[1])
            // 
            // let data = await decryptText(encrypted, iv, deriveKey)
            return dec3

        } catch (e) {
            console.error(`Error -> ${e}`)
        }
    },
    device: async function(useragent) {
        try {
            if (useragent !== null && useragent !== undefined) {
                let detect = new DeviceDetector()
                return detect.parse(useragent);
            } else {
                return {}
            }
        } catch (e) {
            console.error(`Error -> ${e}`)
        }
    },
    AIChat: async function(prompt) {
        try {
            let ax = await fetch(`https://ai.kissass.repl.co/text?prompt=${prompt}`);
            return ax.json()
        } catch (e) {
            console.error(`Error -> ${e}`)
        }
    },
    GAImage: async function(prompt) {
        try {
            let ax = await fetch(`https://ai.kissass.repl.co/gen?prompt=${prompt}`);
            let data = await ax.arrayBuffer()
            return URL.createObjectURL(new Blob([data], { type: 'image/png' }))
        } catch (e) {
            console.error(`Error -> ${e}`)
        }
    },
    Sound: async function(prompt) {
        try {
            let ax = await fetch(`https://ai.kissass.repl.co/sound?prompt=${prompt}`);
            let data = await ax.arrayBuffer()
            return URL.createObjectURL(new Blob([data], { type: 'audio/mp3' }))
        } catch (e) {
            console.error(`Error -> ${e}`)
        }
    }
}

module.exports = {
    Medzy
}